diff --git a/srsepc/src/mme/nas.cc b/srsepc/src/mme/nas.cc
index 1633a2164..24bed1a79 100644
--- a/srsepc/src/mme/nas.cc
+++ b/srsepc/src/mme/nas.cc
@@ -1680,12 +1683,31 @@ bool nas::short_integrity_check(srsran::byte_buffer_t* pdu)
     return false;
   }
 
+  const uint8_t ul_count = (pdu->msg[1] & 0x1f);
+
+  const uint8_t curr_count = (m_sec_ctx.ul_nas_count & 0x1f);
+
+  uint32_t estimated_count = 0;
+
+  if(ul_count >= curr_count)
+   {
+     estimated_count = ((m_sec_ctx.ul_nas_count & 0xffffffe0) + ul_count);
+   }
+  else
+   {
+     // roll over
+     estimated_count = m_sec_ctx.ul_nas_count + (32 - (curr_count - ul_count));
+   }
+
+  m_logger.info("Local: count=%d, Estimated: count=%d, ul_count=%hhu, curr_count=%hhu", 
+                m_sec_ctx.ul_nas_count, estimated_count, ul_count, curr_count);
+
   switch (m_sec_ctx.integ_algo) {
     case srsran::INTEGRITY_ALGORITHM_ID_EIA0:
       break;
     case srsran::INTEGRITY_ALGORITHM_ID_128_EIA1:
       srsran::security_128_eia1(&m_sec_ctx.k_nas_int[16],
-                                m_sec_ctx.ul_nas_count,
+                                estimated_count,
                                 0,
                                 srsran::SECURITY_DIRECTION_UPLINK,
                                 &pdu->msg[0],
@@ -1694,7 +1716,7 @@ bool nas::short_integrity_check(srsran::byte_buffer_t* pdu)
       break;
     case srsran::INTEGRITY_ALGORITHM_ID_128_EIA2:
       srsran::security_128_eia2(&m_sec_ctx.k_nas_int[16],
-                                m_sec_ctx.ul_nas_count,
+                                estimated_count,
                                 0,
                                 srsran::SECURITY_DIRECTION_UPLINK,
                                 &pdu->msg[0],
@@ -1703,7 +1725,7 @@ bool nas::short_integrity_check(srsran::byte_buffer_t* pdu)
       break;
     case srsran::INTEGRITY_ALGORITHM_ID_128_EIA3:
       srsran::security_128_eia3(&m_sec_ctx.k_nas_int[16],
-                                m_sec_ctx.ul_nas_count,
+                                estimated_count,
                                 0,
                                 srsran::SECURITY_DIRECTION_UPLINK,
                                 &pdu->msg[0],
@@ -1713,12 +1735,13 @@ bool nas::short_integrity_check(srsran::byte_buffer_t* pdu)
     default:
       break;
   }
+
   // Check if expected mac equals the sent mac
   for (i = 0; i < 2; i++) {
     if (exp_mac[i + 2] != mac[i]) {
       m_logger.warning("Short integrity check failure. Local: count=%d, [%02x %02x %02x %02x], "
                        "Received: count=%d, [%02x %02x]",
-                       m_sec_ctx.ul_nas_count,
+                       estimated_count,
                        exp_mac[0],
                        exp_mac[1],
                        exp_mac[2],
@@ -1729,7 +1752,9 @@ bool nas::short_integrity_check(srsran::byte_buffer_t* pdu)
       return false;
     }
   }
+
   m_logger.info("Integrity check ok. Local: count=%d, Received: count=%d", m_sec_ctx.ul_nas_count, pdu->msg[1] & 0x1F);
+  m_sec_ctx.ul_nas_count = estimated_count;
   return true;
 }
 
